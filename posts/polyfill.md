# Стандарты и polyfill'ы

## Немного истории

Ecma International — основанная в 1961 году ассоциация, деятельность которой посвящена стандартизации информационных и
коммуникационных технологий. Изначально ассоциация называлась ECMA — European Computer Manufacturers Association, однако
она сменила название в 1994 году в связи с глобализацией деятельности. Вследствие этого название Ecma перестало быть
аббревиатурой и больше не пишется заглавными буквами.
Когда JavaScript был создан, он был представлен Netscape и Sun Microsystems для Ecma, и они дали ему имя ECMA-262 (
псевдоним ECMAScript).

ECMAScript — стандарт, на котором основан JavaScript, его часто называют ES.

До ES2015 спецификации ECMAScript обычно назывались их редакцией. Таким образом, ES5 (пятая редакция стандарта) является
официальным названием обновления спецификации ECMAScript, опубликованной в 2009 году. Обновленный стандарт обычно
публикуется в июне.

С 2015 года было принято решение пересматривать стандарт один раз в год и именовать его в соответствии с годом принятия,
но комьюнити по инерции продолжает использовать именование по порядку редакции стандарта.

Таким образом:
> ES6 = ES2015

> ES7 = ES2016

> ES8 = ES2017

> ES9 = ES2018

> ES10 = ES2019

> ...

## Вечная гонка

Браузеры - самая распространенная среда исполнения JavaScript, в свою очередь, имеют свой релизный цикл и свои темпы
разрабтки и имплементации новый стандартов.
> Например мажорная версия Safari выходит вместе с выходом новой MacOs в сентябре, промежуточные обновления выходят в
> среднем раз в полтора месяца.

Chrome, FireFox, Opera, их мобильные версии - все выходят в разное время, более того, если вышла новая версия,
поддерживающая новый стандарт, огромное количество пользователей продолжают пользоваться более старыми версиями
браузеров, или просто не обновляя версию, или будучи заложниками привязки определенной версии железа и операционной
системы к определенной версии браузера.

В итоге, появившиеся в последнем стандарте EcmaScript нововведения языка еще долго не могут быть напрямую использованы в
браузерах пользователей.

## Решение

Существуют инструменты, которые преобразуют код написанный на более новой версии стандарта для исполнения на более
старых браузерах. К таким инструментам, например, относится транспилятор Babel.

Что он делает?
Он берет новый синтаксис языка, и, в соответствии с конфигурацией и подключенными плагинами, переводит его в версию,
понятную более старым версиям браузерам.
Например в версии ES6 появилась возможность объявлять переменные через `let` и `const`

```js
let a = 3
const b = 4
```

В ES5 же были доступны только `var`

```js
var a = 3
var b = 4
```

Кроме того, используя плагины (например `@babel/preset-env`), можно настроить Babel для поддержку старых версий, добавив
полифиллы отсутствующих методов и браузерных API.

Магическая фраза в конфигурации плагина ```last 2 Chrome versions``` скажет Babel загрузить базу всех версий браузеров
на рынке, выбрать из них две последнии версии браузера Chrome, и загрузить список поддерживаемых ими методов и API.
После этого, Babel, оценив ваш код и выяснив какие именно фичи вы использовали при его написании, добавит в выходной
файл так называемые Polyfill'ы, кусочки кода, которые отработают перед вашим скриптом, и добавят браузеру недостающие
методы.

> Здесь надо отметить, что это не всегда возможно, полифиллы сами по себе будут написаны на том же JS, только более
> старой версии, и если вам требуется какая-то принципиально несовместимая с ним функциональность - то ничего не
> получится. Например если старая более версия браузера не умела доступа до сервиса геолокации на вашем телефоне, то нин
> код не преобразовывай - она не появится.

Однако много что таки можно реализовать, давайте попробуем сделать это сами.

## Array.prototype.flat()

`Array.prototype.flat()` - это метод массивов, уплощающий список вплоть до указанной глубины.

Например:

```js
let array = [1, [2, 3], [[4, 5], [6, 7], [8, 9]]]
array.flat() // -> [1,2,3,4,5,6,7,8,9]
array.flat(2) // -> [1,2,3,[4,5],[6,7],[8,9]]
```

> Давайте представим что мы разработчик Babel плагина в 2017 году (текущий стандарт ES7/ES2016), и мы хотим реализовать
> функциональность, которая уже существует в других языках, а в ECMAScript появится только в ES10(ES2019)

```js
let foldedList = [1, [[2, 3, 4], [5, 6, 7], [8, 9, [10, 11, 12]]], [13, 14, 15], [], [16, 17, 18], [19, 20]]

console.log(foldedList.flat())
/* -> [1,  2,  3,  4,  5,  6,  7,
8,  9, 10, 11, 12, 13, 14,
15, 16, 17, 18, 19, 20 ]
*/
```

В этом примере я так же разберу работу генераторов, которые уже стали частью стандарта в ES7/ES2016, мы попробуем
написать полифилл с их помощью. Особенный интерес представляют циклические генераторы с синтаксисом ```yield*```

Как бы тогда он мог выглядеть?

Сам полифилл я я не буду реализовывать в виде класса Array, а задам метод конкретного объекта массива, чтобы можно было
сравнить поведение нативного метода с реализованным нами. Чтобы полифилл стал настоящим вместо
`foldedList.flat = function (maxDepth) ...` надо просто написать `Array.prototype.flat = function (maxDepth) ...`



```js
function* flatteningGenerator(foldedList, maxDepth = Infinity, depth = 1) {
    for (let i = 0; i < foldedList.length; i++) {
        if (!Array.isArray(foldedList[i])) yield foldedList[i]
        else {
            depth < maxDepth
                ? yield* flatteningGenerator(foldedList[i], maxDepth, depth + 1)
                : yield foldedList[i]
        }
    }
}

let foldedList = [1, [[2, 3, 4], [5, 6, 7], [8, 9, [10, 11, 12]]], [13, 14, 15], [], [16, 17, 18], [19, 20]]

console.log([...foldedList]);

console.log('nativeFlat', foldedList.flat())

foldedList.flat = function (maxDepth) {
    const descendant = Object.create(this)
    descendant[Symbol.iterator] = function () {
        return flatteningGenerator(this, maxDepth)
    }
    return [...descendant]
}

console.log('customFlat', foldedList.flat())
```







