# Стандарты и polyfill'ы

## Немного истории

Ecma International — основанная в 1961 году ассоциация, деятельность которой посвящена стандартизации информационных и
коммуникационных технологий. Изначально ассоциация называлась ECMA — European Computer Manufacturers Association, однако
она сменила название в 1994 году в связи с глобализацией деятельности. Вследствие этого название Ecma перестало быть
аббревиатурой и больше не пишется заглавными буквами.
Когда JavaScript был создан, он был представлен Netscape и Sun Microsystems для Ecma, и они дали ему имя ECMA-262 (
псевдоним ECMAScript).

ECMAScript — стандарт, на котором основан JavaScript, его часто называют ES.

До ES2015 спецификации ECMAScript обычно назывались их редакцией. Таким образом, ES5 (пятая редакция стандарта) является
официальным названием обновления спецификации ECMAScript, опубликованной в 2009 году. Обновленный стандарт обычно
публикуется в июне.

С 2015 года было принято решение пересматривать стандарт один раз в год и именовать его в соответствии с годом принятия,
но комьюнити по инерции продолжает использовать именование по порядку редакции стандарта.

Таким образом:
> ES6 = ES2015

> ES7 = ES2016

> ES8 = ES2017

> ES9 = ES2018

> ES10 = ES2019

> ...

## Вечная гонка

Браузеры - самая распространенная среда исполнения JavaScript, в свою очередь, имеют свой релизный цикл и свои темпы
разрабтки и имплементации новый стандартов.
> Например мажорная версия Safari выходит вместе с выходом новой MacOs в сентябре, промежуточные обновления выходят в
> среднем раз в полтора месяца.

Chrome, FireFox, Opera, их мобильные версии - все выходят в разное время, более того, если вышла новая версия,
поддерживающая новый стандарт, огромное количество пользователей продолжают пользоваться более старыми версиями
браузеров, или просто не обновляя версию, или будучи заложниками привязки определенной версии железа и операционной
системы к определенной версии браузера.

В итоге, появившиеся в последнем стандарте EcmaScript нововведения языка еще долго не могут быть напрямую использованы в
браузерах пользователей.

## Решение

Существуют инструменты, которые преобразуют код написанный на более новой версии стандарта для исполнения на более
старых браузерах. К таким инструментам, например, относится транспилятор Babel.

Что он делает?
Он берет новый синтаксис языка, и, в соответствии с конфигурацией и подключенными плагинами, переводит его в версию,
понятную более старым версиям браузерам.
Например в версии ES6 появилась возможность объявлять переменные через `let` и `const`

```js
let a = 3
const b = 4
```

В ES5 же были доступны только `var`

```js
var a = 3
var b = 4
```

Кроме того, используя плагины (например `@babel/preset-env`), можно настроить Babel для поддержку старых версий, добавив
полифиллы отсутствующих методов и браузерных API.

Магическая фраза в конфигурации плагина ```last 2 Chrome versions``` скажет Babel загрузить базу всех версий браузеров
на рынке, выбрать из них две последнии версии браузера Chrome, и загрузить список поддерживаемых ими методов и API.
После этого, Babel, оценив ваш код и выяснив какие именно фичи вы использовали при его написании, добавит в выходной
файл так называемые Polyfill'ы, кусочки кода, которые отработают перед вашим скриптом, и добавят браузеру недостающие
методы.

> Здесь надо отметить, что это не всегда возможно, полифиллы сами по себе будут написаны на том же JS, только более
> старой версии, и если вам требуется какая-то принципиально несовместимая с ним функциональность - то ничего не
> получится. Например если старая более версия браузера не умела доступа до сервиса геолокации на вашем телефоне, то нин
> код не преобразовывай - она не появится.

Однако много что таки можно реализовать, давайте попробуем сделать это сами.

## Array.prototype.flat()

`Array.prototype.flat()` - это метод массивов, уплощающий список вплоть до указанной глубины.

Например:

```js
let array = [1, [2, 3], [[4, 5], [6, 7], [8, 9]]]
array.flat() // -> [1,2,3,4,5,6,7,8,9]
array.flat(2) // -> [1,2,3,[4,5],[6,7],[8,9]]
```

> Давайте представим что мы разработчик Babel плагина в 2017 году (текущий стандарт ES7/ES2016), и мы хотим реализовать
> функциональность, которая уже существует в других языках, а в ECMAScript появится только в ES10(ES2019)

```js
let foldedList = [1, [[2, 3, 4], [5, 6, 7], [8, 9, [10, 11, 12]]], [13, 14, 15], [], [16, 17, 18], [19, 20]]

console.log(foldedList.flat())
/* -> [1,  2,  3,  4,  5,  6,  7,
8,  9, 10, 11, 12, 13, 14,
15, 16, 17, 18, 19, 20 ]
*/
```

В этом примере я так же разберу работу генераторов, которые уже стали частью стандарта в ES7/ES2016, мы попробуем
написать полифилл с их помощью. Особенный интерес представляют циклические генераторы с синтаксисом ```yield*```
[Про работу генераторов и итераторов можно более детально почитать тут](https://learn.javascript.ru/generators#perebor-generatorov)

Как бы тогда он мог выглядеть?

Сам полифилл я не буду реализовывать в виде метода класса Array, а задам метод конкретного объекта массива, чтобы
можно было сравнить поведение нативного метода с реализованным нами, запустив в рантайме, поддерживающем ES10. Чтобы
полифилл стал настоящим вместо
`foldedList.flat = function (maxDepth) ...` надо будет просто написать `Array.prototype.flat = function (maxDepth) ...`
Также, проведя этот эксперимент, вы заметите что нативный метод делает по-умолчанию развертку массива до глубины 2, а
нам полифилл - до максимальной глубины вложенности. Это поведение конечно можно поменять, заменив `Infinity` на `2`.

Начнем с создания простого генератора, который будет возвращать нам каждый элемент:

```js
function* flatteningGenerator(foldedList) {
    // перечисляем все элементы массива, и возвращаем их из генератора один за гругим
    for (let i = 0; i < foldedList.length; i++) {
        yield foldedList[i]
    }
}
```

Одна иза замечательных особенностей JS - возможность писать рекурсивные функции. К ним добавилась возможность писать
вложенные генераторы.
Оператор ```yield*``` в отличие от обычного ```yield```, получив аргументом инструкции другой генератор, не просто
возвращает его, а начинает циклически обрабатывать инструкции ```yield``` полученного генератора. Таким образом, добавив
рекурсию мы можем развернуть список до самых глубин вложенности, написав простую конструкцию:

```js
function* flatteningGenerator(foldedList) {
    for (let i = 0; i < foldedList.length; i++) {
        // Если в ходе перебора элементов нам попался не массив, то просто верни его
        if (!Array.isArray(foldedList[i])) yield foldedList[i]
        // а если сам элемент является массивом, то начни по очереди возвращать его элементы
        else yield* flatteningGenerator(foldedList[i])
    }
}
```

Давайте добавим возможность управлять глубиной, до которой мы хотим разворачивать список:

```js
// depth - текущая глубина, на которую мы забрались, maxDepth - максимальная, на которую нам позволено
function* flatteningGenerator(foldedList, maxDepth = Infinity, depth = 1) {
    for (let i = 0; i < foldedList.length; i++) {
        if (!Array.isArray(foldedList[i])) yield foldedList[i]
        else {
            depth < maxDepth
                ? yield* flatteningGenerator(foldedList[i], maxDepth, depth + 1)
                : yield foldedList[i]
        }
    }
}
```

Остается определить у нашего иходного массива `foldedList` метод `.flat()`, задав его как
итератор `descendant[Symbol.iterator]` объекта
обертки `descendant` (чтобы не переопределять итератор `Array.prototype`), осуществив развертку в контексте исходного
массива `foldedList`, при помощи написанного ранее рекурсивного генератора `flatteningGenerator`.

```js
function* flatteningGenerator(foldedList, maxDepth = Infinity, depth = 1) {
    for (let i = 0; i < foldedList.length; i++) {
        if (!Array.isArray(foldedList[i])) yield foldedList[i]
        else {
            depth < maxDepth
                ? yield* flatteningGenerator(foldedList[i], maxDepth, depth + 1)
                : yield foldedList[i]
        }
    }
}

let foldedList = [1, [[2, 3, 4], [5, 6, 7], [8, 9, [10, 11, 12]]], [13, 14, 15], [], [16, 17, 18], [19, 20]]

console.log('native flat()', Array.prototype.flat.call(foldedList))

foldedList.flat = function (maxDepth) {
    const descendant = Object.create(this)
    descendant[Symbol.iterator] = function () {
        return flatteningGenerator(this, maxDepth)
    }
    return [...descendant]
}

console.log('custom flat()', foldedList.flat())
```

На выходе получим то, что и ожидалось, уплощенный развернутый массив:

```
native flat() [
  1,
  [ 2, 3, 4 ],
  [ 5, 6, 7 ],
  [ 8, 9, [ 10, 11, 12 ] ],
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20
]
custom flat() [
   1,  2,  3,  4,  5,  6,  7,
   8,  9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20
]
```

Надеюсь мне удалось показать, как на примере синтаксиса, доступного в стандарте ES7, можно написать polyfill для метода,
который появился в стандарте ES10 только три года спустя, а так же с какими трудностями приходится сталкиваться frontend
разработчикам из-за разнообразия браузеров и сред исполнения, вызванного неравномерной реализацией стандата в разных
браузерах.








